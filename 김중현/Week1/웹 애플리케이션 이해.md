# Section 1. 웹 애플리케이션 이해
## 웹 서버, 웹 애플리케이션 서버
### 웹 서버(Web Server)
> 정적 데이터 제공
- HTTP 기반으로 동작
- 정적 리소스, 기타 부가기능 제공
- 정적 리소스: 정적(파일) HTML, CSS, JS, 이미지, 영상
- 정적 리소스를 특정 디렉토리에 두면 server들이 이 파일들을 서빙해준다. 다시 말해, 클라이언트가 HTTP로 특정 리소스를 달라고 웹 서버에 요청하면<br>
  HTTP 프로토콜로 응답한다.
- Ex) NGINX, APACHE
<br>

### 웹 애플리케이션 서버(WAS - Web Application Server)
- HTTP 기반으로 동작
- 웹 서버 기능 포함 + (정적 리소스 제공 가능)
- 프로그램 코드를 실행해 애플리케이션 로직 수행 가능(웹 서버와의 차이점)
  - 웹 서버는 정적인 파일을 서빙만 하기 때문에 파일을 사용자마다 다르게 보여주거나 할 수 없는데 WAS는 프로그래밍 할 수 있기 때문에, <br>
    HTTP 요청이 오면 사용자에 따라 다르게 보여주는 등의 구현을 할 수 있다.
  - 동적 HTML, HTTP API(JSON)
  - 서블릿, JSP, 스프링 MVC 등이 WAS에서 동작
- Ex) Tomcat, Jetty, Undertow
<br>

### 웹 서버와 웹 애플리케이션 서버의 차이
- **웹 서버는 정적 리소스 제공, WAS는 애플리케이션 로직까지 수행 가능**
- 사실 둘의 용어, 경계도 모호하다.
  - 웹 서버가 프로그램을 실행하는 기능을 포함하기도 하고, WAS가 웹 서버의 기능을 제공하기도 한다.
- 자바는 서블릿 컨테이너 기능을 제공하면 WAS이다.
  - 하지만 서블릿 없이 자바 코드를 실행하는 서버 프레임워크도 있다.
- **WAS는 애플리케이션 코드를 실행하는 데 더 특화되어 있다.**
<br>
<br>

### 웹 시스템 구성 - WAS + DB
<img width="600" alt="스크린샷 2022-07-27 오후 4 49 56" src="https://user-images.githubusercontent.com/80838501/181192382-4b90b5db-4676-4089-91cf-cd66b4bf49ba.png">

- WAS, DB 만으로 시스템 구성 가능
  - WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능
- WAS, DB만으로 시스템 구성 시 문제점
  - WAS가 너무 많은 역할을 담당하기 때문에 서버 과부하 우려 
  - 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어렵게 되는 상황이 발생할 수 있다.
  - WAS 장애 발생 시 오류 화면조차도 노출 불가능
<br>

### 웹 시스템 구성 - WEB + WAS + DB
> 실무에서 웹 시스템 구성
<img width="650" alt="스크린샷 2022-07-27 오후 4 50 32" src="https://user-images.githubusercontent.com/80838501/181192450-d7614f79-2978-4fdc-9d52-b9ee3919000f.png">

- 웹 서버를 WAS 앞에 두고 정적 리소스는 웹 서버가 다 처리
- 웹 서버는 애플리케이케이션 로직 같은 동적인 처리가 필요하면 WAS에 요청을 위임
- WAS는 중요한 애플리케이션 로직에 집중 가능
- 효율적인 리소스 관리가 가능
  - 정적 리소스가 많이 사용되면 웹 서버만 증설
  - 애플리케이션 리소스가 많이 사용되면 WAS만 증설
- 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽지만, 정적 리소스만 제공하는 웹 서버는 잘 죽지 않기 때문에 WAS, DB 장애 발생 시 웹 서버가 오류 화면을 제공할 수 있다. 
<br>
<br>
<br>
<br>

## 서블릿
### 서버에서 처리해야 하는 업무
> 웹 애플리케이션 서버를 직접 구현해야 하는 경우
#### 예제
**웹 브라우저가 생성한 요청 HTTP 메시지 - 회원 저장**
```
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

username=kim&age=20
```
<br>

**서버에서 처리해야 하는 업무**
``` markdown
서버 TCP/IP 연결 대기, 소켓 연결 
HTTP 요청 메시지를 파싱해서 읽기
POST 방식, /save URL 인지
Content-Type 확인
HTTP 메시지 바디 내용 파싱
  username, age 데이터를 사용할 수 있게 파싱
저장 프로세스 실행

비즈니스 로직 실행
  데이터베이스에 저장 요청
  
HTTP 응답 메시지 생성 시작
  HTTP 시작 라인 생성
  Header 생성
  메시지 바디에 HTML 생성에서 입력
TCP/IP에 응답 전달, 소켓 종료
```
<br>

**서버에서 생성한 HTTP 응답 메시지**
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
  <body>...</body>
</html>
```
- 서버가 요청 HTTP 메시지를 받아서 응답 메시지를 생성하기까지 처리해야 하는 업무는 위와 같다.
- 비즈니스 로직은 username과 age를 DB에 저장하기만 하면 되는 간단한 일인데, 그 전단계와 후단계가 너무 많다. <br>
→ 비즈니스 로직을 제외한 나머지 작업들을 다 대신 처리해주는 것이 **서블릿**!
<br>
<br>

### 서블릿
```java
@WebServlet(name = "helloServlet", uelPatterns = "/hello")
public class HelloServlet extends HttpServlet {
  
  @Override
  protected void service(HttpSerbletRequest request, HttpServletResponse response) {
    //애플리케이션 로직
  }
}
```
- urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행된다.
- HTTP **요청** 정보를 편리하게 사용할 수 있는 `HttpServletRequest`
- HTTP **응답** 정보를 편리하게 제공할 수 있는 `HttpServletResponse`
- 개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있다.
<br>
<br>

<img width="700" alt="스크린샷 2022-07-27 오후 5 40 25" src="https://user-images.githubusercontent.com/80838501/181207617-2c92ab06-4982-44c3-97b2-3210371cf7cd.png">

```
1. localhost:8080/hello 요청
2. HTTP 요청 메시지를 기반으로 `request`, `response` 객체 생성
3. `request`, `response` 객체를 파라미터로 한 `helloServlet` 실행
4. `response` 객체의 정보를 이용해 HTTP 응답을 생성하고 웹 브라우저에 전달
```
<br>

#### HTTP 요청, 응답 흐름 정리
- WAS는 Request, Respone 객체를 새로 만들어 서블릿 객체 호출
- 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
- 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
- WAS는 최종적으로 Response 객체에 담겨 있는 내용으로 HTTP 응답 정보 생성
<br>
<br>

### 서블릿 컨테이너
- Tomcat처럼 서블릿을 지원하는 WAS를 **서블릿 컨테이너**라고 한다.
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
- 서블릿 객체는 **싱글톤**으로 관리된다.(하나만 생성하고 모두가 공유해서 사용)
  - `request`, `response` 객체는 요청이 들어올 때마다 새로 생성, 서블릿 컨테이너 내의 `서블릿 객체`는 **싱글톤**으로 한 번만 생성되고 제사용된다.
  - 요청이 들어올 때마다 객체를 생성하는 것은 비효율적이므로, 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 <br>
  → 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
  - 공유 변수 사용 주의!
  - 서블릿 컨테이너 종료 시 함께 종료
- JSP도 서블릿으로 변환되어 사용
- WAS의 큰 특징: 동시 요청을 위한 **멀티 스레드 처리 지원**
