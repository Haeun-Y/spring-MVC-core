# Section 1. 웹 애플리케이션 이해
## 웹 서버, 웹 애플리케이션 서버
### 웹 서버(Web Server)
> 정적 데이터 제공
- HTTP 기반으로 동작
- 정적 리소스, 기타 부가기능 제공
- 정적 리소스: 정적(파일) HTML, CSS, JS, 이미지, 영상
- 정적 리소스를 특정 디렉토리에 두면 server들이 이 파일들을 서빙해준다. 다시 말해, 클라이언트가 HTTP로 특정 리소스를 달라고 웹 서버에 요청하면<br>
  HTTP 프로토콜로 응답한다.
- Ex) NGINX, APACHE
<br>

### 웹 애플리케이션 서버(WAS - Web Application Server)
- HTTP 기반으로 동작
- 웹 서버 기능 포함 + (정적 리소스 제공 가능)
- 프로그램 코드를 실행해 애플리케이션 로직 수행 가능(웹 서버와의 차이점)
  - 웹 서버는 정적인 파일을 서빙만 하기 때문에 파일을 사용자마다 다르게 보여주거나 할 수 없는데 WAS는 프로그래밍 할 수 있기 때문에, <br>
    HTTP 요청이 오면 사용자에 따라 다르게 보여주는 등의 구현을 할 수 있다.
  - 동적 HTML, HTTP API(JSON)
  - 서블릿, JSP, 스프링 MVC 등이 WAS에서 동작
- Ex) Tomcat, Jetty, Undertow
<br>

### 웹 서버와 웹 애플리케이션 서버의 차이
- **웹 서버는 정적 리소스 제공, WAS는 애플리케이션 로직까지 수행 가능**
- 사실 둘의 용어, 경계도 모호하다.
  - 웹 서버가 프로그램을 실행하는 기능을 포함하기도 하고, WAS가 웹 서버의 기능을 제공하기도 한다.
- 자바는 서블릿 컨테이너 기능을 제공하면 WAS이다.
  - 하지만 서블릿 없이 자바 코드를 실행하는 서버 프레임워크도 있다.
- **WAS는 애플리케이션 코드를 실행하는 데 더 특화되어 있다.**
<br>
<br>

### 웹 시스템 구성 - WAS + DB
<img width="600" alt="스크린샷 2022-07-27 오후 4 49 56" src="https://user-images.githubusercontent.com/80838501/181192382-4b90b5db-4676-4089-91cf-cd66b4bf49ba.png">

- WAS, DB 만으로 시스템 구성 가능
  - WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능
- WAS, DB만으로 시스템 구성 시 문제점
  - WAS가 너무 많은 역할을 담당하기 때문에 서버 과부하 우려 
  - 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어렵게 되는 상황이 발생할 수 있다.
  - WAS 장애 발생 시 오류 화면조차도 노출 불가능
<br>

### 웹 시스템 구성 - WEB + WAS + DB
> 실무에서 웹 시스템 구성
<img width="650" alt="스크린샷 2022-07-27 오후 4 50 32" src="https://user-images.githubusercontent.com/80838501/181192450-d7614f79-2978-4fdc-9d52-b9ee3919000f.png">

- 웹 서버를 WAS 앞에 두고 정적 리소스는 웹 서버가 다 처리
- 웹 서버는 애플리케이케이션 로직 같은 동적인 처리가 필요하면 WAS에 요청을 위임
- WAS는 중요한 애플리케이션 로직에 집중 가능
- 효율적인 리소스 관리가 가능
  - 정적 리소스가 많이 사용되면 웹 서버만 증설
  - 애플리케이션 리소스가 많이 사용되면 WAS만 증설
- 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽지만, 정적 리소스만 제공하는 웹 서버는 잘 죽지 않기 때문에 WAS, DB 장애 발생 시 웹 서버가 오류 화면을 제공할 수 있다. 
<br>
<br>
<br>
<br>

## 서블릿
### 서버에서 처리해야 하는 업무
> 웹 애플리케이션 서버를 직접 구현해야 하는 경우
#### 예제
**웹 브라우저가 생성한 요청 HTTP 메시지 - 회원 저장**
```
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

username=kim&age=20
```
<br>

**서버에서 처리해야 하는 업무**
``` markdown
서버 TCP/IP 연결 대기, 소켓 연결 
HTTP 요청 메시지를 파싱해서 읽기
POST 방식, /save URL 인지
Content-Type 확인
HTTP 메시지 바디 내용 파싱
  username, age 데이터를 사용할 수 있게 파싱
저장 프로세스 실행

비즈니스 로직 실행
  데이터베이스에 저장 요청
  
HTTP 응답 메시지 생성 시작
  HTTP 시작 라인 생성
  Header 생성
  메시지 바디에 HTML 생성에서 입력
TCP/IP에 응답 전달, 소켓 종료
```
<br>

**서버에서 생성한 HTTP 응답 메시지**
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
  <body>...</body>
</html>
```
- 서버가 요청 HTTP 메시지를 받아서 응답 메시지를 생성하기까지 처리해야 하는 업무는 위와 같다.
- 비즈니스 로직은 username과 age를 DB에 저장하기만 하면 되는 간단한 일인데, 그 전단계와 후단계가 너무 많다. <br>
→ 비즈니스 로직을 제외한 나머지 작업들을 다 대신 처리해주는 것이 **서블릿**!
<br>
<br>

### 서블릿
```java
@WebServlet(name = "helloServlet", uelPatterns = "/hello")
public class HelloServlet extends HttpServlet {
  
  @Override
  protected void service(HttpSerbletRequest request, HttpServletResponse response) {
    //애플리케이션 로직
  }
}
```
- urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행된다.
- HTTP **요청** 정보를 편리하게 사용할 수 있는 `HttpServletRequest`
- HTTP **응답** 정보를 편리하게 제공할 수 있는 `HttpServletResponse`
- 개발자는 HTTP 스펙을 매우 편리하게 사용할 수 있다.
<br>
<br>

<img width="700" alt="스크린샷 2022-07-27 오후 5 40 25" src="https://user-images.githubusercontent.com/80838501/181207617-2c92ab06-4982-44c3-97b2-3210371cf7cd.png">

```
1. localhost:8080/hello 요청
2. HTTP 요청 메시지를 기반으로 request, response 객체 생성
3. request, response 객체를 파라미터로 한 helloServlet 실행
4. response 객체의 정보를 이용해 HTTP 응답을 생성하고 웹 브라우저에 전달
```
<br>

#### HTTP 요청, 응답 흐름 정리
- WAS는 Request, Respone 객체를 새로 만들어 서블릿 객체 호출
- 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
- 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
- WAS는 최종적으로 Response 객체에 담겨 있는 내용으로 HTTP 응답 정보 생성
<br>
<br>

### 서블릿 컨테이너
- Tomcat처럼 서블릿을 지원하는 WAS를 **서블릿 컨테이너**라고 한다.
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
- 서블릿 객체는 **싱글톤**으로 관리된다.(하나만 생성하고 모두가 공유해서 사용)
  - `request`, `response` 객체는 요청이 들어올 때마다 새로 생성, 서블릿 컨테이너 내의 `서블릿 객체`는 **싱글톤**으로 한 번만 생성되고 제사용된다.
  - 요청이 들어올 때마다 객체를 생성하는 것은 비효율적이므로, 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용 <br>
  → 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
  - 공유 변수 사용 주의!
  - 서블릿 컨테이너 종료 시 함께 종료
- JSP도 서블릿으로 변환되어 사용
- WAS의 큰 특징: 동시 요청을 위한 **멀티 스레드 처리 지원**
<br>
<br>
<br>
<br>

## 동시 요청 - 멀티 스레드
### 스레드
- 애플리케이션 코드를 하나하나 순차적으로 실행하는 역할
- 자바 메인 메소드를 처음 실행하면 main이라는 이름의 스레드가 실행된다.
- 스레드는 한 번에 하나의 코드 라인만 수행하고, 동시 처리가 필요하면 스레드를 추가로 생성한다.
- 다중 요청이 들어올 때, 스레드가 하나뿐이라면 처리가 지연되고 오류가 발생하는 상황이 생길 수 있다.<br>
→ 요청이 들어올 때마다 새로운 스레드를 생성하고 요청이 끝나면 없애는 방식
<br>

#### 요청마다 스레드를 생성하는 방식의 장단점
- 장점
  - 동시 요청을 처리할 수 있다.
  - 리소스(CPU, 메모리)가 허용할 때까지 처리가 가능하다.
  - 하아늬 스레드가 지연되더라도 나머지 스레드는 정상 동작한다.
- 단점
  - 스레드 생성 비용이 매우 비싸다.
    - 요청이 들어올 때마다 스레드를 생성하면 응답 속도가 늦어지게 된다.
  - 스레드는 context switching 비용이 발생한다.
  - 스레드 생성에 제한이 없다.
    - 요청이 너무 많이 오면 CPU, 메모리 임계점을 넘게 되어 서버가 죽을 수 있다.
<br>

### 스레드 풀
> 요청마다 스레드를 생성하는 것의 단점을 보완
- 특징
  - 필요한 스레드를 스레드 풀에 보관하고 관리
  - 스레드 풀에 생성 가능한 스레드의 최대치를 관리. Tomcat은 최대 200개가 기본 설정(변경 가능)
  - 스레드를 생성해 풀 안에 미리 넣어놓고 빌려 쓰고 가져다 놓는 방식
- 사용
  - 스레드가 필요하면 스레드 풀에서 이미 생성되어 있는 스레드를 꺼내 사용
  - 사용 종료 시 스레드 풀에 해당 스레드 반납
  - 최대 스레드가 모두 사용중이어서 스레드 풀에 스레드가 없으면 대기 요청을 거절하거나, 특정 숫자만큼 대기하도록 설정 가능
- 장점
  - 스레드가 미리 생성되어 있으므로, 스레드를 생성하고 종료하는 비용(CPU 비용)이 절약되고 응답 시간이 빠르다.
  - 생성 가능한 스레드의 최대치가 존재하므로 너무 많은 요청이 들어와도 기존 요청을 안전하게 처리 가능
<br>

#### 스레드 풀 - 실무 팁
- WAS의 주요 튜닝 포인트는 `최대 스레드(max thread) 수`
- max thread 값을 너무 낮게 설정하면
  - 동시 요청이 많은 경우 서버 리소스는 여유롭지만 클라이언트는 응답이 지연된다.
- max thread 값을 너무 높게 설정하면
  - 동시 요청이 많은 경우 CPU, 메모리 리소스 임계점 초과로 서버가 다운된다.
- 장애 발생 시
  - 클라우드라면 일단 서버부터 늘린 후 튜닝
  - 클라우드가 아니면 튜닝
<br>

#### 스레드 풀의 적정 숫자
- 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황 등에 따라 모두 다르기 때문에 성능 테스트를 통해 적정 숫자를 찾아야 한다.
- 성능 테스트는 최대한 실제 서비스와 유사하게 만들어 시도
  - 툴: 아파치 ab, 제이미터, nGrinder
<br>
<br>

### 핵심 - WAS의 멀티 스레드 지원
- 결국 핵심은 멀티 스레드에 대한 부분은 WAS가 알아서 처리한다는 것이다.
- 개발자는 멀티 스레드 관련 코드를 신경쓰지 않아도 되고, 싱글 스레드 프로그래밍을 하듯이 소스 코드를 개발하면 된다.
- 단, 멀티 스레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용!
